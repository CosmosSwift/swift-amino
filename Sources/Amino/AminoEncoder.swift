//
//  AminoEncoder.swift
//  swift-amino
//

import CoreFoundation


/// A protocol for types which can be encoded to amino.
public protocol AminoEncodable: Encodable, AminoType {
    func aminoEncode(to encoder: AminoEncoder) throws
    func aminoEncode(to encoder: AminoEncoder, _ position: UInt8?) throws
}

/// Provide a default implementation which calls through to `Encodable`. This
/// allows `AminoEncodable` to use the `Encodable` implementation generated by the
/// compiler.

enum Error: Swift.Error {
    case unregisteredConcreteType(AminoInterface.Type)
}

public extension AminoEncodable {
    func aminoEncode(to encoder: AminoEncoder) throws {
        try self.aminoEncode(to: encoder, nil)
    }
    
    func aminoEncode(to encoder: AminoEncoder, _ position: UInt8?) throws {
        // this is called for the non primitives, so struct and interface
        let enc = AminoEncoder()
        if let instance = self as? AminoCodableInterface {
            guard let hash = ConcreteTypeRegistry.getHash(type(of: instance)) else { throw Error.unregisteredConcreteType(type(of: instance))}
            enc.appendBytes(of:hash)
        }
        try self.encode(to: enc)
        enc.prependSize() // TODO: this doesn't work for nested structures
        encoder.append(enc)
        
    }
}


/// The actual amino encoder class.
public class AminoEncoder {

    fileprivate var data: [UInt8] = []
    
    public init() {}
    
    public var bytes: [UInt8] {
        get { return data }
    }
    
    public func append(_ encoder: AminoEncoder) {
        data = data + encoder.data
    }
}

/// A convenience function for creating an encoder, encoding a value, and
/// extracting the resulting data.
public extension AminoEncoder {
    static func encode(_ value: AminoEncodable) throws -> [UInt8] {
        let encoder = AminoEncoder()
        try value.aminoEncode(to: encoder)
        return encoder.data
    }
}

/// The error type.
public extension AminoEncoder {
    /// All errors which `AminoEncoder` itself can throw.
    enum Error: Swift.Error {
        /// Attempted to encode a type which is `Encodable`, but not `AminoEncodable`. (We
        /// require `AminoEncodable` because `AminoEncoder` doesn't support full keyed
        /// coding functionality.)
        case typeNotConformingToAminoEncodable(Encodable.Type)
        
        /// Attempted to encode a type which is not `Encodable`.
        case typeNotConformingToEncodable(Any.Type)
        /// Attempted to encode a type which is not `AminoType`.
        case typeNotConformingToAminoType(Any.Type)

        
        case unregisteredConcreteType(AminoInterface.Type)
        case keyNotConformingToIntegerLiteralType(Any.Type)
    }
}

/// Methods for encoding various types.
public extension AminoEncoder {

 
    func encode(_ encodable: Encodable) throws { // for lists
        switch encodable {

        case let amino as AminoEncodable:
           try amino.aminoEncode(to: self)

        default:
            throw Error.typeNotConformingToAminoEncodable(type(of: encodable))
        }
        
    }
    
    func prependSize() {
        let count = self.data.count
        let varint = varintEncode(count)
        data.insert(contentsOf: varint, at: 0)
    }
    
    /// Append the raw bytes of the parameter to the encoder's data. No byte-swapping
    /// or other encoding is done.
    func appendBytes<T>(of: T) {
        var target = of
        withUnsafeBytes(of: &target) {
            data.append(contentsOf: $0)
        }
    }
    
    /// Append the bytes array of the parameter to the encoder's data.
    func appendBytes(of: [UInt8]) {
            data.append(contentsOf: of)
    }
    
    func appendPrefix(_ position: UInt8, _ typ3: UInt8) {
        appendBytes(of: position << 3 ^ (typ3 & 0x7))
    }
}

extension AminoEncoder : Encoder {
    public var codingPath: [CodingKey] { return [] }
    
    public var userInfo: [CodingUserInfoKey : Any] { return [:] }
    
    public func container<Key>(keyedBy type: Key.Type) -> KeyedEncodingContainer<Key> where Key : CodingKey {
        return KeyedEncodingContainer(KeyedContainer<Key>(encoder: self))
    }
    
    public func unkeyedContainer() -> UnkeyedEncodingContainer {
        return UnkeyedContainer(encoder: self)
    }
    
    public func singleValueContainer() -> SingleValueEncodingContainer {
        return UnkeyedContainer(encoder: self)
    }
    
    private struct KeyedContainer<Key: CodingKey>: KeyedEncodingContainerProtocol {
        var encoder: AminoEncoder
        var codingPath: [CodingKey] { return [] } // TODO: why is this []?

        func encode<T>(_ value: T, forKey key: Key) throws where T : Encodable {
            
            guard let key = key.intValue else { throw Error.keyNotConformingToIntegerLiteralType(Key.self) }
            
            switch value {
            case let v as AminoList & AminoEncodable:
                try v.aminoEncode(to: encoder, (UInt8(key) + 1) << 3 ^ (UInt8(v.typ3) & 0x7))
                
            default:
                if let v = value as? AminoType {
                encoder.appendPrefix(UInt8(key) + 1, UInt8(v.typ3))
                // TODO: should throw if not?
                }
                try encoder.encode(value) // index of position 1 is encoded as 1 (not 0)
            }
        
        }

        
        func encodeNil(forKey key: Key) throws {} // nil in a struct is just empty
        
        func nestedContainer<NestedKey>(keyedBy keyType: NestedKey.Type, forKey key: Key) -> KeyedEncodingContainer<NestedKey> where NestedKey : CodingKey {
            return encoder.container(keyedBy: keyType)
        }
        
        func nestedUnkeyedContainer(forKey key: Key) -> UnkeyedEncodingContainer {
            return encoder.unkeyedContainer()
        }
        
        func superEncoder() -> Encoder {
            return encoder
        }
        
        func superEncoder(forKey key: Key) -> Encoder {
            return encoder
        }
    }
    
    
    // Lists
    private struct UnkeyedContainer: UnkeyedEncodingContainer, SingleValueEncodingContainer {
        var encoder: AminoEncoder
        
        var codingPath: [CodingKey] { return [] } // TODO: why is this []?
        
        var count: Int { return 0 } // TODO: why is this 0?
        
        func nestedContainer<NestedKey>(keyedBy keyType: NestedKey.Type) -> KeyedEncodingContainer<NestedKey> where NestedKey : CodingKey {
            return encoder.container(keyedBy: keyType)
        }
        
        func nestedUnkeyedContainer() -> UnkeyedEncodingContainer {
            return encoder.unkeyedContainer()
        }
        
        func superEncoder() -> Encoder {
            return encoder
        }
        
        func encodeNil() throws {try encoder.encode(UInt8(0x1))} // nil encoded as 0x1 in a list

        
        func encode<T>(_ value: T) throws where T : Encodable {
            try encoder.encode(value)
        }
    }
}
